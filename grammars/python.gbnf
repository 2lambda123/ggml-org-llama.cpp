root ::= (single_input | file_input | eval_input)? EOF
single_input ::= LINE_BREAK | simple_stmt | (compound_stmt LINE_BREAK)
file_input ::= (LINE_BREAK | stmt)+
eval_input ::= testlist LINE_BREAK*
stmt ::= simple_stmt | compound_stmt
compound_stmt ::= (IF test COLON suite elif_clause* else_clause?) | (WHILE test COLON suite else_clause?) | (ASYNC? FOR exprlist IN testlist COLON suite else_clause?) | (TRY COLON suite ((except_clause+ else_clause? finally_clause?) | finally_clause)) | (ASYNC? WITH with_item (COMMA with_item)* COLON suite) | (decorator* (classdef | funcdef))
suite ::= simple_stmt | (LINE_BREAK INDENT stmt+ DEDENT)
decorator ::= AT dotted_name (OPEN_PAREN arglist? CLOSE_PAREN)? LINE_BREAK
elif_clause ::= ELIF test COLON suite
else_clause ::= ELSE COLON suite
finally_clause ::= FINALLY COLON suite
with_item ::= test (AS expr)?
except_clause ::= EXCEPT (test ((COMMA name) | (AS name))?)? COLON suite
classdef ::= CLASS name (OPEN_PAREN arglist? CLOSE_PAREN)? COLON suite
funcdef ::= ASYNC? DEF name OPEN_PAREN typedargslist? CLOSE_PAREN (ARROW test)? COLON suite
typedargslist ::= ((def_parameters COMMA)? ((args (COMMA def_parameters)? (COMMA kwargs)?) | kwargs) COMMA?) | (def_parameters COMMA?)
args ::= STAR named_parameter
kwargs ::= POWER named_parameter
def_parameters ::= def_parameter (COMMA def_parameter)*
def_parameter ::= (named_parameter (ASSIGN test)?) | STAR
named_parameter ::= name (COLON test)?
simple_stmt ::= small_stmt (SEMI_COLON small_stmt)* SEMI_COLON? (LINE_BREAK | EOF)
small_stmt ::= (testlist_star_expr assign_part?) | (PRINT ((test (COMMA test)* COMMA?) | (RIGHT_SHIFT test ((COMMA test)+ COMMA?)))) | (DEL exprlist) | PASS | BREAK | CONTINUE | (RETURN testlist?) | (RAISE (test (COMMA test (COMMA test)?)?)? (FROM test)?) | yield_expr | (IMPORT dotted_as_names) | (FROM (((DOT | ELLIPSIS)* dotted_name) | (DOT | ELLIPSIS)+) IMPORT (STAR | (OPEN_PAREN import_as_names CLOSE_PAREN) | import_as_names)) | (GLOBAL name (COMMA name)*) | (EXEC expr (IN test (COMMA test)?)?) | (ASSERT test (COMMA test)?) | (NONLOCAL name (COMMA name)*)
testlist_star_expr ::= (((test | star_expr) COMMA)+ (test | star_expr)?) | testlist
star_expr ::= STAR expr
assign_part ::= (ASSIGN ((testlist_star_expr (ASSIGN testlist_star_expr)* (ASSIGN yield_expr)?) | yield_expr)) | (COLON test (ASSIGN testlist)?) | ((ADD_ASSIGN | SUB_ASSIGN | MULT_ASSIGN | AT_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | LEFT_SHIFT_ASSIGN | RIGHT_SHIFT_ASSIGN | POWER_ASSIGN | IDIV_ASSIGN) (yield_expr | testlist))
exprlist ::= expr (COMMA expr)* COMMA?
import_as_names ::= import_as_name (COMMA import_as_name)* COMMA?
import_as_name ::= name (AS name)?
dotted_as_names ::= dotted_as_name (COMMA dotted_as_name)*
dotted_as_name ::= dotted_name (AS name)?
test ::= (logical_test (IF logical_test ELSE test)?) | (LAMBDA varargslist? COLON test)
varargslist ::= ((vardef_parameters COMMA)? ((varargs (COMMA vardef_parameters)? (COMMA varkwargs)?) | varkwargs) COMMA?) | (vardef_parameters COMMA?)
vardef_parameters ::= vardef_parameter (COMMA vardef_parameter)*
vardef_parameter ::= (name (ASSIGN test)?) | STAR
varargs ::= STAR name
varkwargs ::= POWER name
logical_test ::= comparison | (NOT logical_test) | (logical_test AND logical_test) | (logical_test OR logical_test)
comparison ::= (comparison (LESS_THAN | GREATER_THAN | EQUALS | GT_EQ | LT_EQ | NOT_EQ_1 | NOT_EQ_2 | (NOT? IN) | (IS NOT?)) comparison) | expr
expr ::= (AWAIT? atom trailer*) | (expr POWER expr) | ((ADD | MINUS | NOT_OP) expr) | (expr (STAR | DIV | MOD | IDIV | AT) expr) | (expr (ADD | MINUS) expr) | (expr (LEFT_SHIFT | RIGHT_SHIFT) expr) | (expr AND_OP expr) | (expr XOR expr) | (expr OR_OP expr)
atom ::= (OPEN_PAREN (yield_expr | testlist_comp)? CLOSE_PAREN) | (OPEN_BRACKET testlist_comp? CLOSE_BRACKET) | (OPEN_BRACE dictorsetmaker? CLOSE_BRACE) | (REVERSE_QUOTE testlist COMMA? REVERSE_QUOTE) | ELLIPSIS | name | PRINT | EXEC | (MINUS? number) | NONE | STRING+
dictorsetmaker ::= (((test COLON test) | (POWER expr)) (COMMA ((test COLON test) | (POWER expr)))* COMMA?) | (test COLON test comp_for) | testlist_comp
testlist_comp ::= (test | star_expr) (comp_for | ((COMMA (test | star_expr))* COMMA?))
testlist ::= test (COMMA test)* COMMA?
dotted_name ::= (dotted_name DOT name) | name
name ::= NAME | TRUE | FALSE
number ::= integer | IMAG_NUMBER | FLOAT_NUMBER
integer ::= DECIMAL_INTEGER | OCT_INTEGER | HEX_INTEGER | BIN_INTEGER
yield_expr ::= YIELD yield_arg?
yield_arg ::= (FROM test) | testlist
trailer ::= (DOT name arguments?) | arguments
arguments ::= (OPEN_PAREN arglist? CLOSE_PAREN) | (OPEN_BRACKET subscriptlist CLOSE_BRACKET)
arglist ::= argument (COMMA argument)* COMMA?
argument ::= (test (comp_for | (ASSIGN test))?) | ((POWER | STAR) test)
subscriptlist ::= subscript (COMMA subscript)* COMMA?
subscript ::= ELLIPSIS | (test (COLON test? sliceop?)?) | (COLON test? sliceop?)
sliceop ::= COLON test?
comp_for ::= FOR exprlist IN logical_test comp_iter?
comp_iter ::= comp_for | (IF test comp_iter?)
