#version 450

#extension GL_EXT_shader_explicit_arithmetic_types : require

#include "mul_mat_vec_base.comp"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (constant_id = 0) const uint BLOCK_SIZE = 32;
layout (constant_id = 1) const uint NUM_ROWS = 1;

shared FLOAT_TYPE tmpsh[NUM_ROWS][BLOCK_SIZE];
shared FLOAT_TYPE sccache[BLOCK_SIZE/16][16];
shared block_q6_K_packed16 blkcache[BLOCK_SIZE/16];
shared B_TYPE bycache[BLOCK_SIZE/16][QUANT_K];

void compute_outputs(const uint32_t first_row, const uint32_t num_rows) {
    uint a_offset, b_offset, d_offset;
    get_offsets(a_offset, b_offset, d_offset);

    const uint num_blocks_per_row = p.ncols / QUANT_K;

    // 16 thread groups are used to process each block
    const uint it_size = gl_WorkGroupSize.x/16;
    const uint tid = gl_LocalInvocationID.x;
    const uint itid = tid%16;  // 0...15
    const uint ix = tid/16;

    const uint v_im = itid/8;                               // 0 or 1. 0 computes 0..., 1 computes 128...
    const uint v_in = itid - 8*v_im;                        // 0...15 or 0...7

    const uint l0 = 4 * v_in;                               // 0, 4, 8, ..., 28
    const uint is = v_in / 4;

    const uint ql_offset = 64*v_im + l0;
    const uint qh_offset = 32*v_im + l0;
    const uint s_offset = 8*v_im + is;
    const uint bcs_offset = (itid%2 == 1) ? 8 : 0;

    FLOAT_TYPE temp[NUM_ROWS];

    [[unroll]] for (uint i = 0; i < NUM_ROWS; ++i) {
        temp[i] = FLOAT_TYPE(0);
    }

    [[unroll]] for (uint i0 = 0; i0 < num_blocks_per_row; i0 += it_size) {
        uint i = i0 + ix; // 16 thread group specific counter
        const uint y_idx = i0 * QUANT_K;
        const int blim = min(int(num_blocks_per_row) - int(i0), 4);

        // assume 64 threads
        [[unroll]] for (int n = 0; n < blim; ++n) {
            [[unroll]] for (int l = 0; l < 4; ++l) {
                bycache[n][tid + 64*l] = data_b[b_offset + y_idx + QUANT_K*n + tid + 64*l];
            }
        }
        barrier();

        uint ibi = first_row*num_blocks_per_row;
        [[unroll]] for (uint n = 0; n < num_rows; ++n) {
            const uint ib0 = a_offset / QUANT_K + ibi;
            ibi += num_blocks_per_row;

            // cache full superblock into shared memory with coalesced reads
            // we assume 64 threads here!
            // this is required as this loop is super sensitive to unrolling with hardcoded 4
            if (blim == 4) {
                if (tid < 52) {
                    [[unroll]] for (int l = 0; l < 4; ++l) {
                        blkcache[l].blk[tid] = data_a_packed16[ib0 + i0 + l].blk[tid];
                        blkcache[l].blk[tid + 52] = data_a_packed16[ib0 + i0 + l].blk[tid + 52];
                    }
                }
            } else {
                if (tid < 52) {
                    [[unroll]] for (int l = 0; l < blim; ++l) {
                        blkcache[l].blk[tid] = data_a_packed16[ib0 + i0 + l].blk[tid];
                        blkcache[l].blk[tid + 52] = data_a_packed16[ib0 + i0 + l].blk[tid + 52];
                    }
                }
            }
            sccache[ix][itid] = FLOAT_TYPE(int8_t(bitfieldExtract(blkcache[ix].blk[96 + itid/2], int(bcs_offset), 8)));
            barrier();
            if (i >= num_blocks_per_row)
                continue;

            const FLOAT_TYPE d = FLOAT_TYPE(data_a[ib0 + i].d);

			FLOAT_TYPE dq[16];
			FLOAT_TYPE sum = 0;
            [[unroll]] for (uint l = 0; l < 16; ++l) {
				dq[l] = bitfieldExtract(blkcache[ix].blk[l/2], 1, 4) | (bitfieldExtract(blkcache[ix].blk[64 + l], 2, 2) << 4);
				sum = fma(FLOAT_TYPE(bycache[ix][16*itid + l]), dq[l], sum);
			}

            temp[n] += sum * sccache[ix][itid] * d;
        }
    }

    // sum up partial sums and write back result
    [[unroll]] for (uint n = 0; n < num_rows; ++n) {
        tmpsh[n][tid] = temp[n];
    }
    barrier();
    [[unroll]] for (uint s = BLOCK_SIZE/2; s > 0; s >>= 1) {
        if (tid < s) {
            [[unroll]] for (uint n = 0; n < num_rows; ++n) {
                tmpsh[n][tid] += tmpsh[n][tid + s];
            }
        }
        barrier();
    }
    if (tid == 0) {
        [[unroll]] for (uint n = 0; n < num_rows; ++n) {
            data_d[d_offset + first_row + n] = D_TYPE(tmpsh[n][0]);
        }
    }
}

void main() {
    const uint first_row = NUM_ROWS * (gl_WorkGroupID.x + gl_NumWorkGroups.x * gl_WorkGroupID.z);

    // do NUM_ROWS at a time, unless there aren't enough remaining rows
    if (first_row + NUM_ROWS <= p.stride_d) {
        compute_outputs(first_row, NUM_ROWS);
    } else {
        if (first_row >= p.stride_d) {
            return;
        }
        compute_outputs(first_row, p.stride_d - first_row);
    }
}
